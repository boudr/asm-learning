#PURPOSE:	THIS PROGRAM WILL CONVERT LOWERCASE TO UPPERCASE IN A FILE

#PROCESSING:	1) OPEN THE INPUT FILE
#		2) OPEN THE OUTPUT FILE
#		3) WHILE WE'RE NOT AT THE END OF THE INPUT FILE:
#			A) READ PART OF FILE INTO MEMORY BUFFER
#			B) GO THROUGH EACH BYTE OF MEMORY
#				IF THE BYTE IS A LOWER-CASE LETTER,
#				CONVERT IT TO UPPPERCASE
#			C) WRTIE THE MEMORY BUFFER TO OUTPUT FILE
.SECTION .DATA

########CONSTANTS########

#SYSTEM CALL NUMBERS
.EQU SYS_OPEN, 5
.EQU SYS_WRITE, 4
.EQU SYS_READ, 3
.EQU SYS_CLOSE, 6
.EQU SYS_EXIT, 1

#OPERATIONS FOR OPEN (LOOK AT /USR/INCLUDE/ASM/FCNTL.H
#FOR VARIOUS VALUES. YOU CAN COMBINE THEM
#BY ADDINT THEM OR ORING THEM)
.EQU O_RDONLY, 0
.EQU O_CREAT_WRONLY_TRUNC, 03101

#STANDARD FILE DESCRIPTORS
.EQU STDIN, 0
.EQU STDOUT, 1
.EQU STDERR, 2

#SYSTEM CALL INTTERUPT
.EQU LINUX_SYSCALL, 0X80

.EQU END_OF_FILE, 0 	#THIS IS THE RETURN VALUE OF READ 
			#WHICH MEANS WE'VE HIT THE END OF THE FILE

.EQU NUM_ARGUMENTS, 2

.SECTION .BSS
#BUFFER - THIS IS WHERE THE DATA IS LOADED INTO
#	FROM THE DATA FILE AND WRITTEN FROM
#	INTO THE OUTPUT FILE. THIS SHOULD
#	NEVER EXCEED 16,000 FOR VARIOUS REASONS.
.EQU BUFFER_SIZE, 500
.LCOMM BUFFER_DATA, BUFFER_SIZE

.SECTION .TEXT
#STACK POSITIONS
.EQU ST_SIZE_RESERVE, 8
.EQU ST_FD_IN, -4
.EQU ST_FD_OUT, -8
.EQU ST_ARGC, 0		#NUMBER OF ARGUMENTS
.EQU ST_ARGV_0, 4	#NAME OF PROGRAM
.EQU ST_ARGV_1, 8	#INPUT FILE NAME
.EQU ST_ARGV_2, 12	#OUTPUT FILE NAME

.GLOBAL _START
_START:
	#SAVE THE STACK POINTER
	MOVL %ESP, %EBP

	#ALLOCATE SPACE FOR OUT FILE DESCRIPTORS ON THE STACK
	SUBL $ST_SIZE_RESERVE, %ESP

OPEN_FILES:
OPEN_FD_IN:
	#OPEN INPUT FILES
	#OPEN SYSCALL
	MOVL $SYS_OPEN, %EAX

	#INPUT FILENAME INTO EBX
	MOVL ST_ARGV_1(%EBP), %EBX

	#READ ONLY FLAG
	MOVL $O_RDONLY, %ECX

	#PERMISSIONS, DOESN'T MATTER FOR READING..
	MOVL $0666, %EDX

	INT $LINUX_SYSCALL
STORE_FD_IN:
	#SAVE THE GIVEN FILE DESCRIPTOR
	MOVL %EAX, ST_FD_IN(%EBP)

OPEN_FD_OUT:
	#OPEN OUTPUT FILE
	MOVL $SYS_OPEN, %EAX

	#OUTPUT FILENAME
	MOVL ST_ARGV_2(%EBP), %EBX

	#FLAGS FOR WRITING TO THE FILE
	MOVL $O_CREAT_WRONLY_TRUNC, %ECX

	#MODE FOR NEW FILE
	MOVL $0666, %EDX

	INT $LINUX_SYSCALL
STORE_FD_OUT:
	#STORE THE FILE DESCRIPTOR HERE
	MOVL %EAX, ST_FD_OUT(%EBP)

READ_LOOP_BEGIN:
	#READ IN A BLOCK FROM THE INPUT FILE
	MOVL $SYS_READ, %EAX

	#GET THE INPUT FILE DESCRIPTOR
	MOVL ST_FD_IN(%EBP), %EBX

	#LOCATION OF BUFFER TO READ INTO
	MOVL $BUFFER_DATA, %ECX

	#BUFFER SIZE
	MOVL $BUFFER_SIZE, %EDX

	#SYSCALL
	INT $LINUX_SYSCALL

	CMPL $END_OF_FILE, %EAX
	JLE END_LOOP

CONT_READ_LOOP:
	#CONVERT THE BLOCK TO UPPERCASE
	PUSHL $BUFFER_DATA
	PUSHL %EAX
	CALL CONVERT_TO_UPPER
	POPL %EAX
	ADDL $4, %ESP

	#SIZE OF THE BUFFER
	MOVL %EAX, %EDX
	MOVL $SYS_WRITE, %EAX

	#FILE TO USE
	MOVL ST_FD_OUT(%EBP), %EBX

	#LOCATION OF THE BUFFER
	MOVL $BUFFER_DATA, %ECX
	INT $LINUX_SYSCALL

	JMP READ_LOOP_BEGIN

END_LOOP:
	#CLOSE THE FILES
	MOVL $SYS_CLOSE, %EAX
	MOVL ST_FD_OUT(%EBP), %EBX
	INT $LINUX_SYSCALL

	MOVL $SYS_CLOSE, %EAX
	MOVL ST_FD_IN(%EBP), %EBX
	INT $LINUX_SYSCALL

	MOVL $SYS_EXIT, %EAX
	MOVL $0, %EBX
	INT $LINUX_SYSCALL

#THIS FUNCTION DOES THE CONVERSION
###CONSTANTS###
.EQU LOWERCASE_A, 'A'
.EQU LOWERCASE_Z, 'Z'

#CONVERSION BETWEEN UPPER AND LOWER.
.EQU UPPER_CONVERSION, 'A' - 'A'

###STACK STUFFS###
.EQU ST_BUFFER_LEN, 8	#LENGTH OF BUFFER
.EQU ST_BUFFER, 12	#BUFFER

CONVERT_TO_UPPER:
	PUSHL %EBP
	MOVL %ESP, %EBP

	MOVL ST_BUFFER(%EBP), %EAX
	MOVL ST_BUFFER_LEN(%EBP), %EBX
	MOVL $0, %EDI			#CURRENT BUFFER OFFSET

	CMPL $0, %EBX
	JE END_CONVERT_LOOP

CONVERT_LOOP:
	#GET THE CURRENT BYTE
	MOVB (%EAX,%EDI,1), %CL

	#GO TO THE NEXT BYTE UNLESS IT IS BETWEEN 'A' AND 'Z'
	CMPB $LOWERCASE_A, %CL
	JL NEXT_BYTE
	CMPB $LOWERCASE_Z, %CL
	JG NEXT_BYTE

	#OTHERWISE CONVERT THE BYTE TO UPPERCASE
	ADDB $UPPER_CONVERSION, %CL

	#STORE IT BACK WHERE IT BELONGS.
	MOVB %CL, (%EAX,%EDI,1)

NEXT_BYTE:
	INCL %EDI
	CMPL %EDI, %EBX
	
	JNE CONVERT_LOOP

END_CONVERT_LOOP:
	#NO RETURN VALUE
	MOVL %EBP, %ESP
	POPL %EBP
	RET
